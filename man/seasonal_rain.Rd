% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/seasonal_rain.R
\name{seasonal_rain}
\alias{seasonal_rain}
\title{Seasonal total rainfall}
\usage{
seasonal_rain(
  summary_data = NULL,
  start_date = NULL,
  end_date = NULL,
  data,
  date_time,
  year = NULL,
  station = NULL,
  doy = NULL,
  rain = NULL,
  s_start_month = 1,
  total_rain = TRUE,
  n_rain = TRUE,
  rain_day = 0.85,
  na_rm = FALSE,
  na_prop = NULL,
  na_n = NULL,
  na_consec = NULL,
  na_n_non = NULL,
  data_book = NULL
)
}
\arguments{
\item{summary_data}{\code{character(1)} Name of the summary data frame in \code{data_book}
that contains the season boundary columns (e.g. \code{start_rain}, \code{end_rains}).}

\item{start_date}{\code{character(1)} Column name in \code{summary_data} giving the start of rains
(typically a day-of-year integer).}

\item{end_date}{\code{character(1)} Column name in \code{summary_data} giving the end of season
(typically a day-of-year integer).}

\item{data}{\code{character(1)} Name of the daily data frame in \code{data_book}.}

\item{date_time}{\code{character(1)} Column name (in \code{data}) of the date variable.}

\item{year}{\code{character(1)} Column name (in \code{data}) of the year variable.
If \code{NULL}, it is created from \code{date_time} using \code{lubridate::year()} with
\code{s_start_month} applied.}

\item{station}{\code{character(1)} Optional station column in \code{data} (useful when \code{data}
contains multiple stations). If supplied, summaries are grouped by \code{station} and \code{year}.}

\item{doy}{\code{character(1)} Column name (in \code{data}) of the day-of-year variable.
If \code{NULL}, it is created from \code{date_time} (366-day DOY) with \code{s_start_month} applied.}

\item{rain}{\code{character(1)} Column name (in \code{data}) of the rainfall variable to summarise.}

\item{s_start_month}{\code{integer(1)} Month (1–12) to treat as the start of the “statistical year”
when deriving \code{year} or \code{doy} from \code{date_time}. Default \code{1} (January).}

\item{total_rain}{\code{logical(1)} Compute and store the seasonal total rainfall. Default \code{TRUE}.}

\item{n_rain}{\code{logical(1)} (Reserved) Compute the number of rainfall days in-season.
Currently not implemented. Default \code{TRUE} (ignored).}

\item{rain_day}{\code{numeric(1)} (Reserved) Threshold (e.g., \code{0.85}) above which a day
counts as a rainfall day when \code{n_rain = TRUE}. Currently ignored.}

\item{na_rm}{\code{logical(1)} Should missing values be removed before summing? Passed through to
the summary calculation. Default \code{FALSE}.}

\item{na_prop}{\code{numeric(1)} Maximum allowed proportion of missing values in the in-season window.}

\item{na_n}{\code{integer(1)} Maximum allowed number of missing values.}

\item{na_consec}{\code{integer(1)} Maximum allowed number of consecutive missing values.}

\item{na_n_non}{\code{integer(1)} Minimum required count of non-missing values.}

\item{data_book}{The \code{DataBook} (R6) object holding \code{data} and \code{summary_data}.
If \code{NULL}, a new one is created internally (side effects then apply to that object).}
}
\value{
Invisibly returns \code{NULL}. The primary effect is to modify \code{summary_data} inside
\code{data_book} by adding a seasonal rainfall total column (and, in future, a rainfall-day count).
Retrieve results with \code{data_book$get_data_frame(summary_data)}.
}
\description{
Compute the seasonal total rainfall between the start of the rains and the end
of the season. The function filters daily data to the interval
\code{start_date}, \code{end_date} (both inclusive) for each grouping (year and, if
provided, station) and then summarises the \code{rain} column. Results are written
back into the \code{summary_data} table stored in \code{data_book}.
}
\details{
If \code{doy} and/or \code{year} are not provided, they are created from \code{date_time}
using \code{data_book$split_date()}, with \code{s_start_month} defining the start of the statistical year.
The function constructs a row-wise filter selecting days \code{doy >= start_date & doy <= end_date}
and then calls \code{data_book$calculate_summary()} with \code{summaries = "summary_sum"} on \code{rain},
grouped by \code{year} (and \code{station}, if supplied).

The newly computed summary column is appended to \code{summary_data} in \code{data_book}. The exact
name of the column depends on the \code{DataBook} summary-naming scheme (commonly includes “sum”
and the variable name, e.g. \code{sum_rain}).

If both \code{total_rain} and \code{n_rain} are \code{FALSE}, the function stops with an error.
Note: as of now, only \code{total_rain} is implemented; \code{n_rain} / \code{rain_day} are reserved.
}
\examples{
# Example workflow: compute start/end, then seasonal totals for Agades (1946–1950 subset)
data_book <- DataBook$new()
daily_data <- rpicsa::daily_niger |>
  dplyr::filter(station_name == "Agades", year > 1945, year <= 1950) |>
  dplyr::mutate(year = as.numeric(year))
data_book$import_data(list(daily_data = daily_data))

start_rains(
  data = "daily_data", date_time = "date", station = "station_name",
  year = "year", rain = "rain", start_day = 121, end_day = 300,
  output = "doy", data_book = data_book
)

end_rains(
  data = "daily_data", date_time = "date", station = "station_name",
  year = "year", rain = "rain", start_day = 121, end_day = 300,
  output = "doy", data_book = data_book
)

seasonal_rain(
  summary_data = "daily_data_by_station_name_year",
  start_date   = "start_rain",
  end_date     = "end_rains",
  data         = "daily_data",
  date_time    = "date",
  year         = "year",
  doy          = "doy",
  station      = "station_name",
  rain         = "rain",
  data_book    = data_book
)

# Inspect results
data_book$get_data_frame("daily_data_by_station_name_year")
}
\seealso{
\code{\link{start_rains}}, \code{\link{end_rains}}, \code{\link{seasonal_length}}
}
