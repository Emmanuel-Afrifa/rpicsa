% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/crops_definitions.R
\name{crops_definitions}
\alias{crops_definitions}
\title{Crop Definitions}
\usage{
crops_definitions(
  data_name,
  year = NULL,
  station = NULL,
  date = NULL,
  doy = NULL,
  rain,
  rain_totals,
  plant_days,
  plant_lengths,
  start_check = c("both", "yes", "no"),
  season_data_name = NULL,
  start_day,
  end_day,
  return_crops_table = TRUE,
  definition_props = TRUE,
  data_book = NULL
)
}
\arguments{
\item{data_name}{\code{character(1)} Name of the daily data frame.}

\item{year}{\code{character(1)} Column name in \code{data_name} giving the year.}

\item{station}{\code{character(1)} Optional. Column name giving the station ID.
If missing, results are computed by year only.}

\item{date}{\code{character(1)}  optional. Column name in \code{data_name} giving the date .}

\item{doy}{\code{character(1)} Column name giving the doy.}

\item{rain}{\code{character(1)} Column name giving daily rainfall (numeric).}

\item{rain_totals}{The amount of water (rainfall) needed for the crop, usually between 250mm and 1000mm
Enter three comma-separated numbers to generate a sequence: from, to, by; for example, 200, 1200, 50 produces 200, 250, 300, ..., 1200.}

\item{plant_days}{The day number for planting. Starting from January, April 1st is day 92. Starting from July, November 1st is day 124.
Enter three comma-separated numbers to generate a sequence: from, to, by; for example, 93, 183, 15 produces 93, 108, 123, …, 183.}

\item{plant_lengths}{The crop duration in days. Often between 60 (2 months) and 150 (5 months).
Enter three comma-separated numbers to generate a sequence: from, to, by; for example, 45, 180, 30 produces 45, 75, 105, ..., 180.}

\item{start_check}{\code{c("both","yes","no")} Whether to (a) compute both start-checked
and no-start variants, (b) require the window to start within the season,
or (c) ignore the seasonal start check (end must still be within season).}

\item{season_data_name}{\code{character(1)} Name of the table containing
\code{start_day}/\code{end_day}. Defaults to \code{data_name}.}

\item{start_day}{\code{character(1)} Column name of the season start day in the
season data.}

\item{end_day}{\code{character(1)} Column name of the season end day in the
season data.}

\item{return_crops_table}{\code{logical(1)} If \code{TRUE}, imports the detailed
row-level window table (\verb{crop_def*}).}

\item{definition_props}{\code{logical(1)} If \code{TRUE}, imports the aggregated
proportions table (\verb{crop_prop*}).}

\item{data_book}{A \code{DataBook} object to use. If \code{NULL}, a new one is created. Default \code{NULL}.}
}
\value{
Invisibly returns \code{NULL}. The primary result is the imported tables and
links created inside the DataBook.
}
\description{
Computes, for many candidate planting windows, whether a rainfall threshold
was met within the window and within seasonal bounds, then imports two tables
into the DataBook:
\itemize{
\item \verb{crop_def*} (row-level windows with conditions and actual rainfall)
\item \verb{crop_prop*} (aggregated proportions of successful windows)
Names are auto-incremented if they already exist (e.g., \code{crop_def2}).
}
}
\details{
For every combination of \code{plant_day} (start-of-window), \code{plant_length}
(window length in days), and \code{rain_total} (required cumulative rainfall),
the function:
\enumerate{
\item Slices the daily series for the given year (and optionally station)
over \verb{[plant_day, plant_day + plant_length)}.
\item Sums rainfall in that slice to \code{rain_total_actual}.
\item Flags whether the window lies within the seasonal bounds:
\code{start_day} <= \code{plant_day} and \code{plant_day + plant_length} <= \code{end_day}.
\item Checks if \code{rain_total_actual} >= \code{rain_total}.
\item Depending on \code{start_check}:
\itemize{
\item \code{"yes"}: requires start and end to be within season and threshold met.
\item \code{"no"}: ignores seasonal start; requires end within season and threshold met.
\item \code{"both"}: computes both variants and reports two proportions.
}
}

NA handling.
\itemize{
\item If the window contains any NA and the (non-NA) sum would be \< \code{rain_total},
the result for that row is set to \code{NA} (i.e., cannot confirm success).
\item If the window is shorter than \code{plant_length} when counting available days,
or all values are NA, the row is \code{NA}.
}

Side effects / links.
\itemize{
\item Imports \verb{crop_def*} and/or \verb{crop_prop*}
\item Creates links between the new tables and (a) the season table (if different)
and (b) between \verb{crop_def*} and \verb{crop_prop*} on the key grid
(\code{rain_total}, \code{plant_length}, \code{plant_day}, and optionally \code{station}).
}
}
\examples{
# Example: compute start/end (DOY) then crop probabilities for Agades (1946–1950 subset)
library(databook)
data_book <- DataBook$new()
daily_data <- rpicsa::daily_niger |>
  dplyr::filter(year > 1945, year <= 1950, station_name == "Agades") |>
  dplyr::mutate(year = as.numeric(year))
data_book$import_data(list(daily_data = daily_data))

start_rains(
  data = "daily_data", date_time = "date", station = "station_name",
  year = "year", rain = "rain", start_day = 121, end_day = 300,
  total_rainfall_over_days = 3,
  output = "doy", data_book = data_book
)

end_rains(
  data = "daily_data", date_time = "date", station = "station_name",
  year = "year", rain = "rain", start_day = 121, end_day = 300,
  output = "doy", data_book = data_book
)

crops_definitions(data_name = "daily_data",
                  year = "year",
                  station = "station_name",
                  doy = "doy",
                  rain = "rain",
                  rain_totals = c(0, 50),
                  plant_days = c(200, 215, 230),
                  plant_lengths = c(15, 30, 45),
                  start_check = "both",
                  season_data_name = "daily_data_by_station_name_year",
                  start_day = "start_rain",
                  end_day = "end_rains",
                  return_crops_table = TRUE, 
                  definition_props = TRUE,
                  data_book = data_book)

# View the crop definitions data 
head(data_book$get_data_frame("crop_def"))

# View the crop probability summaries
data_book$get_data_frame("crop_prop")
}
